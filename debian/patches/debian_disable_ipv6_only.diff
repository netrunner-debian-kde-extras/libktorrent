Description: Always bind IPv6 sockets to IPv4 as well
 If net.ipv6.bindv6only = 1 (Linux defaults to net.ipv6.bindv6only = 0) is set
 (a new default for Debian Linux since Squeeze), IPv6 sockets are not bound to
 IPv4 by default. This made KTorrent not listen on IPv4 (see Debian bug).
 However, an application may explicitly set IPV6_V6ONLY socket option to 0 in
 order to enforce contrary behaviour on Linux and other systems which support
 IPv4-mapped addresses.
 .
 Unfortunately, this fix is just a workaround and my attempt at damage control.
 According to [1], not all IPv6 stacks support IPv4-mapped addresses (Windows,
 OpenBSD, Debian kFreeBSD do not support them). What is more, as far as I can
 tell, net.ipv6.bindv6only=1 like behaviour is default on *BSD. So KTorrent
 without IPV6_V6ONLY explicitly set to 0 used to bind to IPv6-only addresses on
 these systems. Only Linux and OSX default to net.ipv6.bindv6only=0 like
 behaviour.
 .
 The proper fix would be to open two sockets: one AF_INET6 with IPV6_V6ONLY and
 another AF_INET one. I recommend you to read the thread [2] about bindv6only=1
 in Debian in order to better understand this issue.
 .
 1. http://en.wikipedia.org/wiki/IPv6#IPv4-mapped_addresses
 2. http://news.gmane.org/find-root.php?message_id=%3c20091024182431.GB13333%40bongo.bofh.it%3e
Author: Modestas Vainius <modax@debian.org>
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=581896
Origin: vendor
Forwarded: yes
Last-Update: 2010-05-24

--- a/src/net/socket.cpp
+++ b/src/net/socket.cpp
@@ -183,7 +183,7 @@ namespace net
 	
 	bool Socket::bind(const QString & ip,Uint16 port,bool also_listen)
 	{
-		int val = 1;
+		int val = 1, no = 0;
 #ifndef Q_WS_WIN
 		if (setsockopt(m_fd,SOL_SOCKET,SO_REUSEADDR,&val,sizeof(int)) < 0)
 #else
@@ -192,6 +192,10 @@ namespace net
 		{
 			Out(SYS_CON|LOG_NOTICE) << QString("Failed to set the reuseaddr option : %1").arg(strerror(errno)) << endl;
 		}
+		// Bind this socket to IPv4 as well. This is a workaround for systems
+		// which support IPv4-mapped addresses but have them disabled by
+		// default (e.g. net.ipv6.bindv6only=1 on Debian Linux).
+		setsockopt (m_fd,SOL_IPV6,IPV6_V6ONLY,&no,sizeof(no));
 
 		net::Address addr(ip,port);
 		if (::bind(m_fd,addr.address(),addr.length()) != 0)
@@ -212,7 +216,7 @@ namespace net
 	
 	bool Socket::bind(const net::Address& addr, bool also_listen)
 	{
-		int val = 1;
+		int val = 1, no = 0;
 #ifndef Q_WS_WIN
 		if (setsockopt(m_fd,SOL_SOCKET,SO_REUSEADDR,&val,sizeof(int)) < 0)
 #else
@@ -221,6 +225,10 @@ namespace net
 		{
 			Out(SYS_CON|LOG_NOTICE) << QString("Failed to set the reuseaddr option : %1").arg(strerror(errno)) << endl;
 		}
+		// Bind this socket to IPv4 as well. This is a workaround for systems
+		// which support IPv4-mapped addresses but have them disabled by
+		// default (e.g. net.ipv6.bindv6only=1 on Debian Linux).
+		setsockopt (m_fd,SOL_IPV6,IPV6_V6ONLY,&no,sizeof(no));
 		
 		if (::bind(m_fd,addr.address(),addr.length()) != 0)
 		{
